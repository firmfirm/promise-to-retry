<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-button/paper-button.html">

<!--
An element to make sure that some action returning `Future` succeeds
before user can continue using your app.

If it fails, shows a dialog popup that prompts user to retry until it succeeds.

Example:

    <link rel="import" href="promise-to-retry.html">

    <promise-to-retry>
      <h2>Some content asking to retry</h2>
    </promise-to-retry>

    <script>
      document.querySelector('promise-to-retry').ensureSuccess(function() {
        return someFunctionReturningPromiseThatMightFail();
      }).then(continueUsingYourApp);
    </script>

@element promise-to-retry
@homepage https://firmfirm.github.io/promise-to-retry/components/promise-to-retry
@demo demo/index.html
-->
<dom-module id="promise-to-retry">

  <template>
    <style>
      :host {
        position: fixed;
        margin: 0;
        padding: 0;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: none;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        z-index: 2147483647;
        background: rgba(51, 51, 51, 0.9);
      }

      :host > .container {
        background: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        padding: 2vh;
      }

    </style>
    <i18-n-domain domain="promise-to-retry"></i18-n-domain>
    <div class="container">
      <content></content>
      <paper-button raised on-click="_onRetryClick">
        <iron-icon icon="refresh"></iron-icon>
      </paper-button>
      <paper-spinner active></paper-spinner>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'promise-to-retry',

    properties: {

      /**
       * `numTries` indicates the number of unsuccessful tries made
       */
      numTries: {
        type: Number,
        notify: true,
        value: 0
      }

    },

    // Element Behavior

    /**
     * The `num-tries-changed` event is fired after every
     * unsuccessful try to resolve the promise.
     * Also called when resetting numTries back to 0 on subsequent
     * `ensureSuccess` calls.
     *
     * @event num-tries-changed
     */

    /**
     * Invoke provided function.
     * If it fails, shows a dialog popup that
     * prompts user to retry until it succeeds
     *
     * @param {Function} function that must return a promise
     * @return {Promise} that it guaranteed not to fail and returns
     * result of provided function
     */
    ensureSuccess: function(func) {
      var self = this;
      var result = new Promise(function(resolve) {
        self._resolve = resolve;
      });
      this.numTries = 0;
      this._func = func;
      this._retry();
      return result;
    },

    _retry: function() {
      var self = this;
      this._func().then(function(result) {
        self._resolve(result);
        self._close();
      }).catch(function() {
        self._setVisibility(self, true);
        self._resolving(false);
        self.numTries = self.numTries+1;
      });
    },

    _onRetryClick: function() {
      this._setMinContainerHeight();
      this._resolving(true);
      this._retry();
    },

    _resolving: function(resolving) {
      this._setVisibility(this.querySelector('paper-spinner'), resolving);
      this._setVisibility(this.querySelector('paper-button'), !resolving);
    },

    _setVisibility: function(el, visible) {
      el.style.display = visible ? 'inline-block' : 'none';
    },

    _close: function() {
      this._setVisibility(this.querySelector('paper-spinner'), false);
      this._setVisibility(this.querySelector('paper-button'), false);
      this._setVisibility(this, false);
    },

    _setMinContainerHeight: function() {
      var container = this.querySelector('.container');
      if (!container.style.minHeight) {
        var getPadding = function(direction) { return parseFloat(window.getComputedStyle(container, null).getPropertyValue('padding-'+direction)); };
        var padding = getPadding('top') + getPadding('bottom');
        container.style.minHeight = (container.clientHeight - padding) + 'px';
      }
    }

  });

</script>
