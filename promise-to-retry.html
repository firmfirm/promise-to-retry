<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-button/paper-button.html">

<!--
An element to make sure that some action returning `Future` succeeds
before user can continue using your app.

If it fails, shows a dialog popup that prompts user to retry until it succeeds.

Example:

    <link rel="import" href="promise-to-retry.html">

    <promise-to-retry>
      <h2>Some content asking to retry</h2>
    </promise-to-retry>

    <script>
      document.querySelector('promise-to-retry').ensureSuccess(function() {
        return someFunctionReturningPromiseThatMightFail();
      }).then(continueUsingYourApp);
    </script>

@element promise-to-retry
@homepage https://firmfirm.github.io/promise-to-retry/components/promise-to-retry
@demo demo/index.html
-->
<dom-module id="promise-to-retry">

  <template>
    <style>
      :host {
        position: fixed;
        margin: 0;
        padding: 0;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: none;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        z-index: 2147483647;
        background: rgba(51, 51, 51, 0.9);
      }

      :host > .container {
        background: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        padding: 2vh;
      }

    </style>
    <div class="container">
      <content></content>
      <paper-button raised on-click="_onRetryClick">
        <iron-icon icon="refresh"></iron-icon>
      </paper-button>
      <paper-spinner active></paper-spinner>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'promise-to-retry',

    properties: {
      _tasks: {
        type: Object,
        value: function() { return {} }
      }
    },

    // Element Behavior

    /**
     * The `fail` event is fired after every failed try.
     * @detail {{name:String, try:Number, wait:Number}}
     *
     * @event fail
     */

    /**
     * Invoke provided function.
     * If it fails, shows a dialog popup that
     * prompts user to retry until it succeeds
     *
     * @param {Function} func function that must return a promise
     * @param {String} name task name, which is used to identify task on `fail` event.
     * @return {Promise} that it guaranteed not to fail and returns
     * result of provided function
     */
    ensureSuccess: function(func, name) {
      if (!func || !name) throw "Missing func or name in ensureSuccess"
      return new Promise(function(resolve) {
        this._tasks[name] = {
          resolve: resolve,
          func: func,
          tries: 0
        };
        this._retry(name);
      }.bind(this));
    },

    /**
     * Invoke provided function. Similar to ensureSuccess, except that it doesnt
     * ask anything from user and does retries automatically, which each retry having
     * a bigger delay.
     *
     * @param {Function} func function that must return a promise
     * @param {String} name task name, which is used to identify task on `fail` event.
     * @return {Promise} that it guaranteed not to fail and returns
     * result of provided function
     */
    ensureSuccessAuto: function(func, name) {
      if (!func || !name) throw "Missing func or name in ensureSuccess"
      var numTries = 0;
      var fn = function() {
        return func().catch(function() {
          var wait = 100 * Math.pow(2, ++numTries);
          this.fire('fail', {
            tries: numTries,
            name: name,
            wait: wait
          });
          return this.asyncPromise(fn, wait).catch(fn);
        }.bind(this));
      }.bind(this)
      return fn();
    },

    /**
     * Similar to Polymer's `async`, except that it returns result of function.
     * @param {Function} func function that must return a promise
     * @param {Number} wait wait time in ms before executing function
     */
    asyncPromise: function(func, wait) {
      var resolve, reject;
      var promise = new Promise(function(_resolve, _reject) {
        resolve = _resolve;
        reject = _reject;
      });
      this.async(function() { func().then(resolve, reject); }, wait);
      return promise;
    },

    _retry: function(name) {
      this._tasks[name].func().then(function(result) {
        this._tasks[name].resolve(result);
        this._close();
      }.bind(this)).catch(function() {
        this._setVisibility(this, true);
        this._resolving(false);
        this._taskName = name;
        var task = this._tasks[name];
        task.tries = task.tries+1;
        this.fire('fail', {
          try: task.tries,
          name: name
        })
      }.bind(this));
    },

    _onRetryClick: function() {
      this._setMinContainerHeight();
      this._resolving(true);
      this._retry(this._taskName);
    },

    _resolving: function(resolving) {
      this._setVisibility(this.querySelector('paper-spinner'), resolving);
      this._setVisibility(this.querySelector('paper-button'), !resolving);
    },

    _setVisibility: function(el, visible) {
      el.style.display = visible ? 'inline-block' : 'none';
    },

    _close: function() {
      this._setVisibility(this.querySelector('paper-spinner'), false);
      this._setVisibility(this.querySelector('paper-button'), false);
      this._setVisibility(this, false);
    },

    _setMinContainerHeight: function() {
      var container = this.querySelector('.container');
      if (!container.style.minHeight) {
        var getPadding = function(direction) { return parseFloat(window.getComputedStyle(container, null).getPropertyValue('padding-'+direction)); };
        var padding = getPadding('top') + getPadding('bottom');
        container.style.minHeight = (container.clientHeight - padding) + 'px';
      }
    }

  });

</script>
